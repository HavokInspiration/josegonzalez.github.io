<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jose Diaz-Gonzalez</title>
    <description>Developer, Accidental Ops Guy, and CakePHP Core Developer</description>
    <link>http://josediazgonzalez.com/</link>
    <atom:link href="http://josediazgonzalez.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 06 Dec 2015 00:59:23 +0000</pubDate>
    <lastBuildDate>Sun, 06 Dec 2015 00:59:23 +0000</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Uploading files and images with CakePHP 3</title>
        <description>&lt;p&gt;I’ve been working for years on upload plugins. CakePHP 1.2 users might remember MeioUpload - such a good plugin, it did &lt;em&gt;all&lt;/em&gt; the things. Which ended up being a bad move for maintainability. Something I took to heart when I worked on other alternatives, and when I finally wrote my &lt;a href=&quot;https://github.com/josegonzalez/cakephp-upload&quot;&gt;CakePHP Upload&lt;/a&gt; plugin. Until recently however, it supported only 2.x, and in this post-3.0 world, this just wouldn’t cut it.&lt;/p&gt;

&lt;p&gt;If you are using CakePHP 3, there have been a &lt;a href=&quot;https://github.com/WyriHaximus/FlyPie&quot;&gt;few&lt;/a&gt; &lt;a href=&quot;https://github.com/josbeir/image&quot;&gt;different&lt;/a&gt; &lt;a href=&quot;https://github.com/davidyell/CakePHP3-Proffer&quot;&gt;upload&lt;/a&gt; &lt;a href=&quot;https://github.com/Xety/Cake3-Upload&quot;&gt;plugins&lt;/a&gt;. In my mind, the &lt;a href=&quot;https://github.com/davidyell/CakePHP3-Proffer&quot;&gt;Proffer&lt;/a&gt; plugin is the spiritual successor to the 2.x Upload plugin. If you need something more or less drop-in, I recommend looking into it. But this post isn’t about the Proffer plugin, but rather the new version of my &lt;a href=&quot;https://github.com/josegonzalez/cakephp-upload&quot;&gt;own upload plugin&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;focus&quot;&gt;Focus&lt;/h2&gt;

&lt;p&gt;One thing I hated about the old plugin version is the fact that I was manually handling image thumbnails. There are plenty &lt;a href=&quot;https://github.com/avalanche123/Imagine&quot;&gt;of&lt;/a&gt; &lt;a href=&quot;https://github.com/Gregwar/Image&quot;&gt;awesome&lt;/a&gt; &lt;a href=&quot;https://github.com/Intervention/image&quot;&gt;packages&lt;/a&gt; to handle this already. Upload did it in a hacky way, with interpolated php logic coming from a regex-parsed string. And only sometimes did it work. And anything advanced, like adding a watermark, was mostly impossible. Sad panda.&lt;/p&gt;

&lt;p&gt;If you wanted to upload a file to S3, that was impossible without further work. Handling local files required a hacky behavior. Quite annoying when really the code changes should have been minimal.&lt;/p&gt;

&lt;p&gt;The other thing is that it was hard to test the code. So many codepaths to handle complex logic that honestly didn’t need to be there.&lt;/p&gt;

&lt;p&gt;So with the 3.x plugin, I’ve resolved to the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Only add code with 100% unit test coverage.&lt;/li&gt;
  &lt;li&gt;Stick to file uploading only.&lt;/li&gt;
  &lt;li&gt;Use external libraries for handling file storage.&lt;/li&gt;
  &lt;li&gt;Remove code that wasn’t strictly related to file uploading, like validation or image manipulation.&lt;/li&gt;
  &lt;li&gt;Provide class-based entry points into the lifecycle of a file upload.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;uploading-a-file&quot;&gt;Uploading a file&lt;/h2&gt;

&lt;p&gt;First install the thing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer require josegonzalez/cakephp-upload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then load it in your &lt;code&gt;config/bootstrap.php&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;Plugin::load(&#39;Josegonzalez/Upload&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a sample &lt;code&gt;UsersTable&lt;/code&gt; that implements file uploading:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Model\Table;

use App\Model\Entity\User;
use Cake\ORM\Table;

class UsersTable extends Table
{

    public function initialize(array $config)
    {
        $this-&amp;gt;table(&#39;users&#39;);
        $this-&amp;gt;displayField(&#39;name&#39;);
        $this-&amp;gt;primaryKey(&#39;id&#39;);
        $this-&amp;gt;addBehavior(&#39;Josegonzalez/Upload.Upload&#39;, [
            &#39;photo&#39;,
        ]);
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty basic. It will upload anything to the path &lt;code&gt;webroot/files/Users/photo/ID&lt;/code&gt;, and save metadata about the file to the &lt;code&gt;photo&lt;/code&gt; field. We still have a few of the same config options, with many of the same defaults. For instance, we may wish to change the upload path to be outside of &lt;code&gt;webroot&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;addBehavior(&#39;Josegonzalez/Upload.Upload&#39;, [
    &#39;photo&#39; =&amp;gt; [
        &#39;path&#39; =&amp;gt; &#39;static{DS}{model}{DS}{field}{DS}{primaryKey}&#39;,
    ],
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also save metadata about the file upload to three fields, &lt;code&gt;dir&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, and &lt;code&gt;type&lt;/code&gt;. We can customize those just as easily:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;addBehavior(&#39;Josegonzalez/Upload.Upload&#39;, [
    &#39;photo&#39; =&amp;gt; [
        &#39;fields&#39; =&amp;gt; [
            &#39;dir&#39; =&amp;gt; &#39;photo_dir&#39;,
            &#39;size&#39; =&amp;gt; &#39;size_dir&#39;,
            &#39;type&#39; =&amp;gt; &#39;type_dir&#39;,
        ],
    ],
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also upload multiple files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;addBehavior(&#39;Josegonzalez/Upload.Upload&#39;, [
    &#39;photo&#39;,
    &#39;video&#39;
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;customizing-the-file-upload&quot;&gt;Customizing the file upload&lt;/h2&gt;

&lt;p&gt;CakePHP Upload does all the heavy-lifting using a new interface system. You can configure new classes to implement three key areas of file handling:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;addBehavior(&#39;Josegonzalez/Upload.Upload&#39;, [
    &#39;photo&#39; =&amp;gt; [
        // A pathProcessor handles both returning the basepath
        // as well as what the initial filename should be set to
        &#39;pathProcessor&#39; =&amp;gt; &#39;Josegonzalez\Upload\File\Path\DefaultProcessor&#39;

        // Allows you to create new files from the original source,
        // or possibly even modify/remove the original source file
        // from the upload process
        &#39;transformer&#39; =&amp;gt; &#39;Josegonzalez\Upload\File\Transformer\DefaultTransformer&#39;

        // Handles writing a file to disk... or S3... or Dropbox... or FTP... or /dev/null
        &#39;writer&#39; =&amp;gt; &#39;Josegonzalez\Upload\File\Writer\DefaultWriter&#39;,
    ],
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For anyone wondering, the above system allows us to do any of the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Handle arbitrary naming and pathing schemas&lt;/li&gt;
  &lt;li&gt;Add or remove original files to the upload&lt;/li&gt;
  &lt;li&gt;Extract video thumbnails&lt;/li&gt;
  &lt;li&gt;Add watermarks to files&lt;/li&gt;
  &lt;li&gt;Sanitize uploaded files&lt;/li&gt;
  &lt;li&gt;Write those files to anywhere &lt;a href=&quot;http://flysystem.thephpleague.com/&quot;&gt;Flysystem&lt;/a&gt; supports&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Want to create a thumbnail and upload both the original and your new file to S3? Install the AWS S3 Flysystem adapter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer require league/flysystem-aws-s3-v3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And follow along as we rock your socks off&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$client = \Aws\S3\S3Client::factory([
    &#39;credentials&#39; =&amp;gt; [
        &#39;key&#39;    =&amp;gt; &#39;your-key&#39;,
        &#39;secret&#39; =&amp;gt; &#39;your-secret&#39;,
    ],
    &#39;region&#39; =&amp;gt; &#39;your-region&#39;,
    &#39;version&#39; =&amp;gt; &#39;latest&#39;,
]);
$adapter = new \League\Flysystem\AwsS3v3\AwsS3Adapter(
    $client,
    &#39;your-bucket-name&#39;,
    &#39;optional-prefix&#39;
);

$this-&amp;gt;addBehavior(&#39;Josegonzalez/Upload.Upload&#39;, [
    &#39;photo&#39; =&amp;gt; [
        // Ensure the default filesystem writer writes using
        // our S3 adapter
        &#39;filesystem&#39; =&amp;gt; [
            &#39;adapter&#39; =&amp;gt; $adapter
        ],

        // This can also be in a class that implements
        // the TransformerInterface or any callable type.
        &#39;transformer&#39; =&amp;gt; function (Table $table, Entity $entity, $data, $field, $settings) {
            $tmp = tmpfile();
            $size = new \Imagine\Image\Box(40, 40);
            $mode = \Imagine\Image\ImageInterface::THUMBNAIL_INSET;
            $imagine = new \Imagine\Gd\Imagine();
            $imagine-&amp;gt;open($data[&#39;tmp_name&#39;])
                    -&amp;gt;thumbnail($size, $mode)
                    -&amp;gt;save($tmp);
            return [
                $tmp =&amp;gt; &#39;thumbnail-&#39; . $data[&#39;name&#39;],
                $data[&#39;tmp_name&#39;] =&amp;gt; $data[&#39;name&#39;]
            ];
        }
    ],
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A list of methods needed to implement the proper interfaces &lt;a href=&quot;https://cakephp-upload.readthedocs.org/en/latest/interfaces.html&quot;&gt;are here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;things-yet-to-do&quot;&gt;Things yet to do&lt;/h2&gt;

&lt;p&gt;One thing that is sorely missing is upload file validation. Yes, you’re going to have to write these on your own. The Proffer plugin has these available, though in my mind the validation rules should be in their own plugin so &lt;em&gt;all&lt;/em&gt; upload plugins can benefit by just adding a &lt;code&gt;require&lt;/code&gt; statement to their &lt;code&gt;composer.json&lt;/code&gt;. Also, I’m lazy, and didn’t want to write a custom Validator class.&lt;/p&gt;

&lt;p&gt;Documentation is a bit sparse - the above docs are the first to show exactly how powerful the plugin can be - but that will be ameliorated over time.&lt;/p&gt;

&lt;h2 id=&quot;a-note-of-caution&quot;&gt;A note of caution&lt;/h2&gt;

&lt;p&gt;One thing I’d like to stress is that the less you do during a page request, the faster your response time will be and the more likely your users will use your site. Here’s a &lt;a href=&quot;http://searchengineland.com/googles-push-to-speed-up-your-web-site-42177&quot;&gt;helpful post&lt;/a&gt; on just how important that be to numbers like, idk, user retention and revenue.&lt;/p&gt;

&lt;p&gt;Given that information, I’d caution you against handling image manipulation etc. within a web request. This will work fine for some websites and internal administrative tools, but at some point you’re going to have to bite the bullet and refactor this code (and potentially even move the image uploading to outside of PHP entirely!). If only there was a way of combining file uploading and background processing…&lt;/p&gt;

&lt;p&gt;Until next time!&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/04/uploading-files-and-images/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/04/uploading-files-and-images/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>upload</category>
        
        <category>files</category>
        
        <category>images</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>What exactly belongs in an entity?</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Sorry for the lateness, I was at a basketball game. The Nets lost against the Knicks, if anyone was wondering.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I’ve been in a few arguments about what an “entity” is. CakePHP 3 introduced them as a new way of representing a distinct set of data from a collection of “things”. Typically, that means a row in a table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$post = new Post;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For a very long time, this was not how CakePHP abstracted information. You had an array, you modified an array, you saved an array, you deleted an array. GRONK WAS HAPPY!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.catster.com/wp-content/uploads/2015/06/RobGronkowski4.png&quot; alt=&quot;My cowork Rick O&#39;Hanlon&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Honestly though, the array stuff was quite annoying, and most (all?) CakePHP are happy we replaced them in CakePHP 3. The ORM changes that came along with it were… weird, but make sense once you think about them. But what exactly do I gain with an entity?&lt;/p&gt;

&lt;h2 id=&quot;custom-entity-data&quot;&gt;Custom Entity Data&lt;/h2&gt;

&lt;p&gt;An entity is a bag of data. It is a data bag. You put some data in it, and you can get that data out.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;breathe&lt;/em&gt; &lt;em&gt;plays anna nalick&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When you first use an entity, you should treat it as a dumb object. Previously, we would say “Fat Models, Skinny Controllers”. I think the same way about entities. Entities are fairly stupid. They know about themselves and not much else. That is to say, entities don’t and shouldn’t know how to save themselves, what it means to be a valid entity (save the mid-life crisis for a table), or really much of anything.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Entities are for holding data and virtually constructed data.&lt;/em&gt; If you have a &lt;code&gt;Post&lt;/code&gt; entity with information about a post, it may be able to constuct it’s published date, the number of views it has, or whether it is active or not, but it should &lt;em&gt;not&lt;/em&gt; know whether or not it is the latest version of a post, or whether it’s internal state is valid. These things should be left to tables and validators.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In the case of validators, they may change the state of an entity to add errors etc., but I don’t think of this as the state. The ORM will refuse to save an invalid entity, so really all you have is a bad bag of data that you need to clean up. The validation errors tell you how to do that.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;what-is-in-an-entity&quot;&gt;What is in an Entity?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://1.bp.blogspot.com/-6d78XHD9qIQ/TsE7oLbG_nI/AAAAAAAAABE/XgB3ci9zv4o/s1600/Baby+names.jpg&quot; alt=&quot;No really, what the hell does an entity stand for?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We’ve always had “App” classes in PHP. What is an &lt;code&gt;App&lt;/code&gt; class? It’s literally a parent class that we use to contain some amount of default logic. You can create as many of these as you’d like. The &lt;code&gt;App&lt;/code&gt; prefix is just a standard, I like to call mine &lt;code&gt;Lolipop&lt;/code&gt;  classes when no one is looking.&lt;/p&gt;

&lt;p&gt;Here is my default &lt;code&gt;LolipopEntity&lt;/code&gt; class (hey, we have object oriented programming up in the hizouze!). You can place what you’d like in yours, I recommend seeing what is common and just doing that once:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Model\Entity;

use App\Model\Entity\Traits\JsonApi;
use Cake\ORM\Entity;

class LolipopEntity extends Entity
{
    use JsonApi;
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay, that is cheating. You can see I include the &lt;code&gt;JsonApi&lt;/code&gt; trait, and here it is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Model\Entity\Traits;

use Cake\Routing\Router;
use Cake\Utility\Inflector;

trait JsonApi
{
    public static function className()
    {
        $classname = get_called_class();
        if (preg_match(&#39;@\\\\([\w]+)$@&#39;, $classname, $matches)) {
            $classname = $matches[1];
        }

        return $classname;
    }

    public function _getType()
    {
        $classname = static::className();
        return Inflector::classify($classname);
    }

    public function _getRoute()
    {
        $classname = static::className();

        return [
            &#39;controller&#39; =&amp;gt; Inflector::pluralize(Inflector::classify($classname)),
            &#39;action&#39; =&amp;gt; &#39;view&#39;,
            &#39;_method&#39; =&amp;gt; &#39;GET&#39;,
            &#39;id&#39; =&amp;gt; $this-&amp;gt;id,
        ];
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;JsonApi&lt;/code&gt; trait is something I use for building out APIs. My &lt;code&gt;AppEntity&lt;/code&gt; sometimes includes a &lt;code&gt;toArray&lt;/code&gt; that pulls in these false methods, or I include them manually in subclasses. I also have other related methods that build upon the data an entity has to create information &lt;em&gt;about&lt;/em&gt; that entity.&lt;/p&gt;

&lt;p&gt;Entities are bags of data, and while they are supposed to be stupid, in my view they should understand how to reference themselves. This is controversial amongst the core developers, but I take this stance because I like to keep my code DRY.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DONT REPEAT YOURSELF. Repeat after me (because I won’t!).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let’s say you have a database of events. Each event has a url, and you have custom routes for that url (to include seo information etc.). Each time you change the custom route, you may or may not have to change route information included to generate that route.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;Html-&amp;gt;link(&#39;Awesome Event with Milkshakes&#39;, [
  &#39;controller&#39; =&amp;gt; &#39;Events&#39;,
  &#39;action&#39; =&amp;gt; &#39;view&#39;,
  &#39;id&#39; =&amp;gt; $entity-&amp;gt;id,
  &#39;slug&#39; =&amp;gt; $entity-&amp;gt;slug,
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At some point, writing the above out gets annoying. And while the reference to an object happens in the presentation layer and is probably easily done in a helper, isn’t it nice to do something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;Html-&amp;gt;link(&#39;Awesome Event with Milkshakes&#39;, $entity-&amp;gt;getRoute());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The alternative is a helper to which you pass an entity, or always writing out the array.&lt;/p&gt;

&lt;h2 id=&quot;a-best-practice-or-at-least-a-practice&quot;&gt;A Best Practice, or at least a “Practice”&lt;/h2&gt;

&lt;p&gt;While I may disagree with the core developers on what goes where, we can all agree that at the end of the day, you should strive to write the least amount of code that works which won’t give you a headache at some other time. In my case, it is adding some presentational data to the &lt;code&gt;entity&lt;/code&gt; object. Maybe in your case, that means never using plugins or shirking away from namespaces.&lt;/p&gt;

&lt;p&gt;Remember, there are many ways to skin a cat (please don’t hurt my cat). So long as you aren’t increasing anyone’s cognitive load, choose the method that involves the least code.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Always code as if the person who ends up maintaining your code is a violent psychopath who knows where you live. - &lt;a href=&quot;http://c2.com/cgi/wiki?CodeForTheMaintainer&quot;&gt;Code For The Maintainer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 04 Dec 2015 12:00:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/04/whats-in-an-entity/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/04/whats-in-an-entity/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>table</category>
        
        <category>entity</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Generating Administrative Panels with CrudView</title>
        <description>&lt;p&gt;Since time immemorial - okay, 2009 - it has been possible to set a custom view for CakePHP applications:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// Don&#39;t try this, there isn&#39;t an ExcelView in the core :P
$this-&amp;gt;viewBuilder()-&amp;gt;className(&#39;ExcelView&#39;)
$this-&amp;gt;viewClass = &#39;ExcelView&#39;;

// Who remembers this from 1.x?
$this-&amp;gt;viewClass = &#39;MediaView&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since then, the number of view classes has increased dramatically, and we even have ways to map certain types of responses to particular view classes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;RequestHandler-&amp;gt;config(&#39;viewClassMap&#39;, [
    // troll all your xml users
    &#39;xml&#39; =&amp;gt; &#39;Json&#39;,
    // this is from a plugin
    &#39;xlsx&#39; =&amp;gt; &#39;CakeExcel.Excel&#39;,
    // so is this!
    &#39;csv&#39; =&amp;gt; &#39;CsvView.Csv&#39;,
    // we are really into this plugin thing aren&#39;t we
    &#39;rss&#39; =&amp;gt; &#39;Feed.Rss&#39;
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the nice things about views is that they completely take over the rendering step, allowing you to create views that automatically generate interactive experiences. Similar to how the Crud plugin allows users to generate api responses, the CrudView plugin allows users to generate administrative panels.&lt;/p&gt;

&lt;h2 id=&quot;crudview&quot;&gt;CrudView&lt;/h2&gt;

&lt;p&gt;The CrudView plugin is actually one of the more difficult plugins to use, owing to the fact that there is basically zero documentation - we’re working on it! It works similar to how the Crud plugin does, using &lt;code&gt;events&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; options to lay everything out &lt;em&gt;just&lt;/em&gt; right.&lt;/p&gt;

&lt;p&gt;To start, you’ll want to install the bugger:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer require friendsofcake/crud-view:dev-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The simplest method of using CrudView is to configure the Crud &lt;code&gt;listener&lt;/code&gt; and &lt;code&gt;viewClass&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Controller;

use Cake\Controller\Controller;
use Crud\Controller;
use Crud\Controller\ControllerTrait;

class AppController extends Controller
{
    use ControllerTrait;

    public function initialize()
    {
        parent::initialize();

        $this-&amp;gt;loadComponent(&#39;RequestHandler&#39;);
        $this-&amp;gt;loadComponent(&#39;Flash&#39;);

        // setup the viewclass
        $this-&amp;gt;viewBuilder()-&amp;gt;className(&#39;CrudView\View\CrudView&#39;)
        $this-&amp;gt;loadComponent(&#39;Crud.Crud&#39;, [
            &#39;actions&#39; =&amp;gt; [
                &#39;Crud.Index&#39;,
                &#39;Crud.Add&#39;,
                &#39;Crud.Edit&#39;,
                &#39;Crud.View&#39;,
                &#39;Crud.Delete&#39;,
            ],
            &#39;listeners&#39; =&amp;gt; [
                // and ensure we have the listener configured
                &#39;CrudView.View&#39;,
                &#39;Crud.RelatedModels&#39;,
                &#39;Crud.Redirect&#39;,
            ],
        ]);
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s it! We now have automatic view scaffolding for every controller that inherits from the &lt;code&gt;AppController&lt;/code&gt;, &lt;em&gt;as well as&lt;/em&gt; all the yummy api stuff the Crud plugin gives us by default.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/03/admin.png&quot; alt=&quot;Crud View Admin&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;hiding-sidebar-entries&quot;&gt;Hiding Sidebar Entries&lt;/h3&gt;

&lt;p&gt;CrudView is only as smart as you configure it to be. By default, it will show &lt;em&gt;all&lt;/em&gt; tables in the sidebar and link to their assumed administrative panels. I personally prefer not to show join tables, or anything related to database migrations, and as such my &lt;code&gt;AppController::beforeFilter&lt;/code&gt; looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function beforeFilter(Event $event)
{
    $this-&amp;gt;Crud-&amp;gt;action()-&amp;gt;config(&#39;scaffold.tables_blacklist&#39;, [
        &#39;blog_phinxlog&#39;,
        &#39;phinxlog&#39;,
        &#39;posts_tags&#39;,
    ]);

    return parent::beforeFilter($event);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/03/limit-sidebar.png&quot; alt=&quot;Crud View Admin&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;showing-specific-fields-for-specific-actions&quot;&gt;Showing specific fields for specific actions&lt;/h3&gt;

&lt;p&gt;On my index actions for Categories and Tags, I’d like to hide most fields and just show the &lt;code&gt;name&lt;/code&gt; field:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function beforeFilter(Event $event)
    if ($this-&amp;gt;request-&amp;gt;action == &#39;index&#39;) {
        $this-&amp;gt;Crud-&amp;gt;action()-&amp;gt;config(&#39;scaffold.fields&#39;, [&#39;name&#39;]);
    }
    return parent::beforeFilter($event);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/03/show-specific-fields.png&quot; alt=&quot;Showing specific fields&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Of note, you can also set these config options in specific actions, the same as you would to customize the crud plugin, but sometimes you can avoid that with very trivial hacks. I wouldn’t do the above if there was 10 lines of configuration for the IndexAction, for instance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;exposing-bulk-actions&quot;&gt;Exposing bulk actions&lt;/h3&gt;

&lt;p&gt;Sometimes I’d like to expose bulk post actions to my administrative users in a simple to use interface. CrudView takes a tact similar to wordpress and provides a checkboxes next to each row that can be used to “apply” configured actions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function initialize()
{
    parent::initialize();
    // map a fiew bulk actions
    $this-&amp;gt;Crud-&amp;gt;mapAction(&#39;deleteAll&#39;, &#39;Crud.Bulk/Delete&#39;);
    $this-&amp;gt;Crud-&amp;gt;mapAction(&#39;setStatus&#39;, [
        &#39;className&#39; =&amp;gt; &#39;Crud.Bulk/SetValue&#39;,
        &#39;field&#39; =&amp;gt; &#39;status&#39;,
    ]);
}
public function beforeFilter(Event $event)
{
    // provide the proper links to the actions
    $this-&amp;gt;Crud-&amp;gt;action()-&amp;gt;config(&#39;scaffold.bulk_actions&#39;, [
        Router::url([&#39;action&#39; =&amp;gt; &#39;deleteAll&#39;]) =&amp;gt; __(&#39;Delete selected&#39;),
        Router::url([&#39;action&#39; =&amp;gt; &#39;setStatus&#39;, &#39;status&#39; =&amp;gt; &#39;published&#39;]) =&amp;gt; __(&#39;Make published&#39;),
        Router::url([&#39;action&#39; =&amp;gt; &#39;setStatus&#39;, &#39;status&#39; =&amp;gt; &#39;pending-review&#39;]) =&amp;gt; __(&#39;Set to pending&#39;),
    ]);
    return parent::beforeFilter($event);
}

public function setStatus()
{
    $this-&amp;gt;_statusOptions = [
        &#39;published&#39; =&amp;gt; &#39;Published&#39;,
        &#39;pitch&#39; =&amp;gt; &#39;Pitch&#39;,
        &#39;assigned&#39; =&amp;gt; &#39;Assigned&#39;,
        &#39;in-progress&#39; =&amp;gt; &#39;In Progress&#39;,
        &#39;pending-review&#39; =&amp;gt; &#39;Pending Review&#39;,
    ];

    $value = $this-&amp;gt;request-&amp;gt;query(&#39;status&#39;);
    if (!in_array($value, array_keys($this-&amp;gt;_statusOptions))) {
        throw new BadRequestException(&#39;No valid status specified&#39;);
    }

    // ZHU LI, DO THE THING!
    $this-&amp;gt;Crud-&amp;gt;action()-&amp;gt;config(&#39;value&#39;, $value);
    return $this-&amp;gt;Crud-&amp;gt;execute();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/03/bulk-actions.png&quot; alt=&quot;Showing specific fields&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Obviously the logic here can get incredibly complex, and you are welcome to integrate both Crud and CrudView to best express these sorts of experiences for your users.&lt;/p&gt;

&lt;h2 id=&quot;youre-getting-sleepy&quot;&gt;You’re getting sleepy&lt;/h2&gt;

&lt;p&gt;Building administrative interfaces isn’t the most illustrious job out there, but if you ever find yourself in a pinch, the CrudView plugin is there to help. Hopefully the above will give you enough of a primer to find your way through the plugin, and we’ll continue plugging on it until it’s both polished and well-documented. Until tomorrow!&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Dec 2015 13:42:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/03/generating-administrative-panels-with-crud-view/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/03/generating-administrative-panels-with-crud-view/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>api</category>
        
        <category>crud</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Creating APIs using the CRUD Plugin</title>
        <description>&lt;p&gt;For anyone who has used CakePHP for the past 3 years, this will seem like kicking a dead horse, but here it is. The &lt;a href=&quot;https://github.com/friendsofcake/crud&quot;&gt;CRUD&lt;/a&gt; plugin is the finest way to rapidly build out apis in CakePHP, and certainly one of the best ways to do so in web application development.&lt;/p&gt;

&lt;p&gt;Lets say we were building an api for interacting with a blog. At the very least, we’d need the following controllers:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Tags&lt;/li&gt;
  &lt;li&gt;Categories&lt;/li&gt;
  &lt;li&gt;Posts&lt;/li&gt;
  &lt;li&gt;Users&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can use cake bake to create/recreate them as many times as you’d like, and you can customize your bake templates to do &lt;em&gt;exactly&lt;/em&gt; as you need. While this is certainly a fine approach, there are a few issues you’ll find with it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It is quite destructive to existing code, as it overwrites files.&lt;/li&gt;
  &lt;li&gt;All the generated code still needs tests.&lt;/li&gt;
  &lt;li&gt;While bake finally supports automatically generating api responses, these responses do not always conform to a “sane” format.&lt;/li&gt;
  &lt;li&gt;You are generating hundreds of lines of code which still need to be audited.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-typical-crud-application&quot;&gt;A typical CRUD Application&lt;/h2&gt;

&lt;p&gt;Here is a CRUD blog plugin I wrote:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace Blog\Controller\Admin;

use Blog\Controller\AppController as BaseController;
use Cake\Event\Event;
use Crud\Controller\ControllerTrait;

class AppController extends BaseController
{
    use ControllerTrait;

    public function initialize()
    {
        parent::initialize();
        $this-&amp;gt;loadComponent(&#39;RequestHandler&#39;);
        $this-&amp;gt;loadComponent(&#39;Crud.Crud&#39;, [
            &#39;actions&#39; =&amp;gt; [
                &#39;Crud.Index&#39;,
                &#39;Crud.Add&#39;,
                &#39;Crud.Edit&#39;,
                &#39;Crud.View&#39;,
                &#39;Crud.Delete&#39;,
            ],
            &#39;listeners&#39; =&amp;gt; [
                &#39;Crud.RelatedModels&#39;,
                &#39;Crud.Redirect&#39;,
            ],
        ]);
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, that’s 30 lines of code that sets up all my basic actions, responds with json/xml/whatever I like, with full unit-test coverage. The underlying controllers are relatively simple as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace Blog\Controller\Admin;

use Blog\Controller\Admin\AppController;

class PostsController extends AppController
{
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it feels like cheating, that’s because it is. But this isn’t an exam, and you have better things to do than worry about the minute details of &lt;code&gt;public function add&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;custom-actions&quot;&gt;Custom Actions&lt;/h2&gt;

&lt;p&gt;One complaint about the CRUD plugin is that it seems limited to just CRUD-actions, and doesn’t seem to be easy to extend. Both of these are patently false.&lt;/p&gt;

&lt;p&gt;The CRUD plugin comes with 5 different base action classes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;CreateAction&lt;/code&gt;: Create an entity.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;DeleteAction&lt;/code&gt;: Delete an entity.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EditAction&lt;/code&gt;: Edit a single entity.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ViewAction&lt;/code&gt;: View a single entity.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IndexAction&lt;/code&gt;: List many entities via pagination.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But we also have 3 special actions for dealing with entities in bulk:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;BulkDeleteAction&lt;/code&gt;: Delete one or more entities at once&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;BulkSetValueAction&lt;/code&gt;: Set a value for many entities at the same time&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;BulkToggleAction&lt;/code&gt;: Toggle boolean fields for many entities at once&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is even a special action for the &lt;a href=&quot;https://github.com/friendsofcake/crud-view&quot;&gt;Crud-View&lt;/a&gt; plugin:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;LookupAction&lt;/code&gt;: Displays a record from a data source for auto-complete purposes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While the names of these actions is set in stone, it is easy to imagine yourself creating an action for scoping certain fields for editing by a post submitter, and then giving an editor even more control. This is done through the use of custom CakePHP events like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function add()
{
    $this-&amp;gt;Crud-&amp;gt;on(&#39;beforeSave&#39;, function(\Cake\Event\Event $event) {
        // do whatever you want with the event-&amp;gt;subject and data
    });
    // continue on with the rest of the action
    return $this-&amp;gt;Crud-&amp;gt;execute();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The awesome thing about the CRUD plugin is that it is quite easy to create single-purpose actions for your own use. For instance, a recent plugin I was contracted to do has a custom &lt;code&gt;AutocompleteAction&lt;/code&gt; that integrates with &lt;a href=&quot;https://brianreavis.github.io/selectize.js/&quot;&gt;selectize.js&lt;/a&gt; to handle tagging. I’ve also created similar actions for Login/Logout.&lt;/p&gt;

&lt;h2 id=&quot;going-further&quot;&gt;Going Further&lt;/h2&gt;

&lt;p&gt;While CRUD does simplify a ton of work around creating APIs for applications, many applications &lt;em&gt;also&lt;/em&gt; need administrative panels for users who don’t want to use &lt;code&gt;curl&lt;/code&gt; to interact with your websites. Thankfully, the &lt;a href=&quot;https://github.com/friendsofcake/crud-view&quot;&gt;&lt;code&gt;Crud-View&lt;/code&gt;&lt;/a&gt; plugin is available for just such purposes, and we’ll cover it’s use tomorrow.&lt;/p&gt;

&lt;p&gt;Bonus: Read this lovely tutorial on adding &lt;a href=&quot;http://www.bravo-kernel.com/2015/04/how-to-add-jwt-authentication-to-a-cakephp-3-rest-api/&quot;&gt;JWT Auth to a Crud application&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Dec 2015 13:42:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/02/creating-apis-using-the-crud-plugin/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/02/creating-apis-using-the-crud-plugin/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>api</category>
        
        <category>crud</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Using Fractal to transform entities for custom api endpoints</title>
        <description>&lt;p&gt;In a CakePHP 3 application, you can very easily create Apis with entity objects. Each entity implements the &lt;code&gt;JsonSerializable&lt;/code&gt; interface, and you can customize the output by creating a custom &lt;code&gt;toArray()&lt;/code&gt; method (or &lt;code&gt;jsonSerialize()&lt;/code&gt; if you want to skip a step):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Model\Entity;
use Cake\ORM\Entity;
use Cake\Routing\Router;

class Post extends Entity
{
    public function toArray()
    {
        // Special logic goes here
        $data = parent::toArray();
        return $data;
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you serialized a set of these entities, you would have something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  [{
    &quot;id&quot;: 6,
    &quot;title&quot;: &quot;Herp derpes&quot;,
    &quot;year&quot;: null
  }]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not great, especially if this serialization changes from endpoint to endpoint.&lt;/p&gt;

&lt;p&gt;A few months ago, it was requested that there be a way to define endpoint-specific entity serialization, which is difficult with the above type of setup. There are a few methods to go about such a thing, one of which is to use a custom View class that will automatically wrap entities.&lt;/p&gt;

&lt;h2 id=&quot;fractal&quot;&gt;Fractal&lt;/h2&gt;

&lt;p&gt;Fractal is a php package by The PHP League whose description is as follows:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Fractal provides a presentation and transformation layer for complex data output, the like found in RESTful APIs, and works really well with JSON. Think of this as a view layer for your JSON/YAML/etc.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Isn’t that nice? Using fractal, we can write wrappers around arbitrary inputs and have arbitrary outputs. Fractal supports quite a few types of &lt;a href=&quot;http://fractal.thephpleague.com/transformers/&quot;&gt;transformations&lt;/a&gt; and &lt;a href=&quot;http://fractal.thephpleague.com/serializers/&quot;&gt;serializers&lt;/a&gt;, so be sure to check them out.&lt;/p&gt;

&lt;p&gt;Note that we &lt;em&gt;could&lt;/em&gt; have created our own data-wrapping library, but why bother? We can and should use pre-existing libraries wherever possible for several reasons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The code is (hopefully) better tested&lt;/li&gt;
  &lt;li&gt;It may provide additional features you have not yet thought of&lt;/li&gt;
  &lt;li&gt;More mindshare can sometimes mean easier onboarding of developers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Similar to how we shouldn’t re-invent a framework for work purposes, we should also strive for code re-use wherever it is feasible. In our case, The PHP League provides &lt;a href=&quot;https://thephpleague.com/&quot;&gt;quite a few delicious libraries&lt;/a&gt; (in some cases similar to those provided by CakePHP itself!) we can sprinkle around our CakePHP application.&lt;/p&gt;

&lt;h2 id=&quot;fractalentities&quot;&gt;FractalEntities&lt;/h2&gt;

&lt;p&gt;Rather than have to build such integrations over and over, I built a single-purpose plugin for this case. As the use-case was very simple, it doesn’t have many options - nor docs for that matter - but this post should serve as a good example of how to use it going forward.&lt;/p&gt;

&lt;p&gt;In our case, we’re going to use a wrapper plugin called FractalEntities to create a nicer-version of the json output that looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;data&quot;: [{
    &quot;id&quot;: 6,
    &quot;title&quot;: &quot;Herp derpes&quot;,
    &quot;year&quot;: null,
    &quot;links&quot;: [{
      &quot;rel&quot;: &quot;self&quot;,
      &quot;uri&quot;: &quot;\/blog\/post-1&quot;
    }]
  }]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, lets start out by installing the plugin using composer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;composer require josegonzalez/cakephp-fractal-entities
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will install our wrapper &lt;code&gt;TransformerView&lt;/code&gt; class which does the heavy lifting.&lt;/p&gt;

&lt;p&gt;The simplest setup will be to set the current &lt;code&gt;Controller::$viewClass&lt;/code&gt; to the &lt;code&gt;TransformerView&lt;/code&gt; and set your data for serialization:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;viewBuilder()-&amp;gt;className(&#39;FractalEntities.Transformer&#39;)
$this-&amp;gt;set(&#39;_serialize&#39;, &#39;posts&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we will define a transformer class. The namespace of each transformer class is interpolated based upon the current request path like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// if you are missing any param, assume you don&#39;t
// need that section in the class namespace
$path = array_filter([
    &#39;App&#39;,
    &#39;Transformer&#39;,
    $this-&amp;gt;request-&amp;gt;param(&#39;plugin&#39;),
    $this-&amp;gt;request-&amp;gt;param(&#39;prefix&#39;),
    $this-&amp;gt;request-&amp;gt;param(&#39;controller&#39;),
    $this-&amp;gt;request-&amp;gt;param(&#39;action&#39;) . &#39;Transformer&#39;,
], &#39;strlen&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For &lt;code&gt;/posts/view/1&lt;/code&gt; - assuming no plugins or prefixes - you will need the following file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;src/Transformer/Posts/ViewTransformer.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with the following class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
namespace App\Transformer\Posts;

use App\Model\Entity\Post;
use League\Fractal\TransformerAbstract;

class IndexTransformer extends TransformerAbstract
{
    /**
     * Creates a response item for each instance
     *
     * @param Post $post post entity
     * @return array transformed post
     */
    public function transform(Post $post)
    {
        return [
            &#39;id&#39; =&amp;gt; (int)$post-&amp;gt;get(&#39;id&#39;),
            &#39;title&#39; =&amp;gt; $post-&amp;gt;get(&#39;title&#39;),
            &#39;year&#39; =&amp;gt; $post-&amp;gt;get(&#39;published_date&#39;),
            &#39;links&#39; =&amp;gt; [
                [
                    &#39;rel&#39; =&amp;gt; &#39;self&#39;,
                    &#39;uri&#39; =&amp;gt; &#39;/books/&#39; . $post-&amp;gt;get(&#39;route&#39;),
                ]
            ],
        ];
    }
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All transformers will need a &lt;code&gt;transform&lt;/code&gt; method, which will take a single entity of whatever type you are turning into an api response. Note that due to our use of Fractal, we can be sure that whether we are converting a single entity or an entire resultset, the response will always be converted properly.&lt;/p&gt;

&lt;h2 id=&quot;is-this-best-practice&quot;&gt;Is this “best practice”?&lt;/h2&gt;

&lt;p&gt;The answer to that is “maybe”. Perhaps for your application, separating the presentation layer from your entity layer will work out really well due to the myriad of ways data can be represented. This might also result in a lot of extra classes that are harder to navigate, or extra magic that may be difficult to understand later.&lt;/p&gt;

&lt;p&gt;One nice thing about this method is that it is quite easy to separate presentation-layer unit tests from those relating to the entity itself. Because the entity is being wrapped away from where your business logic is located, it’s much easier to reason about how the output itself.&lt;/p&gt;

&lt;p&gt;Tomorrow I’ll show you a powerful alternative for json api creation.&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Dec 2015 13:42:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2015/12/01/using-fractal-to-transform-entities-for-custom-api-endpoints/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2015/12/01/using-fractal-to-transform-entities-for-custom-api-endpoints/</guid>
        
        <category>cakeadvent-2015</category>
        
        <category>cakephp</category>
        
        <category>api</category>
        
        <category>entities</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Sending email invoices to users on payment</title>
        <description>&lt;p&gt;Once a user has made a purchase, they will likely want some sort of proof that the purchase went through. We can send them an email at every step of the way. We’ll start by sending an email as soon as the purchase was completed.&lt;/p&gt;

&lt;p&gt;CakePHP’s email system allows us to use Templates to send email. We previously briefly covered email sending while building the anonymous issue tracker - though simply using raw messages. CakePHP is capable of sending messages both as plaintext and as html, and is also capable of wrapping emails in layouts. Here is a simple, contrived example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// Load the class at the top of your class using the `use` statement
use Cake\Network\Email\Email;
// Construct an email object
$email = new Email();
// Send the email using the template in `src/Template/Email/TYPE/herp.ctp`
// and the layout in `src/Template/Layout/Email/TYPE/derp.ctp`
// Type is the type of the message
$email-&amp;gt;template(&#39;herp&#39;, &#39;derp&#39;);
// Send the email as a multi-part type message, both as `text` and `html`.
// This means that the previous `template` call configures 4 different
// files for use when sending
$email-&amp;gt;emailFormat(&#39;both&#39;);
// Send the email to this user
$email-&amp;gt;to(&#39;camilla@number1.com&#39;);
// Specify this user to send as
$email-&amp;gt;from(&#39;app@domain.com&#39;);
// Actually send the email!
$email-&amp;gt;send();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we are going to do is send a simple, plain-text email that uses a text template and a text layout. Let’s start by creating a &lt;code&gt;src/Template/Email/text/purchase.ctp&lt;/code&gt; file with the following contents:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;Hi!
We&#39;re messaging you to let you know someone made a purchase for &amp;lt;?= $amount ?&amp;gt; at &amp;lt;?= $purchase_time ?&amp;gt; under the email &amp;lt;?= $user[&#39;email&#39;] ?&amp;gt;. If this seems incorrect, let us know!
The following items were purchased:
&amp;lt;?php foreach ($order_items as $order_item) :?&amp;gt;
- &amp;lt;?= $order_item-&amp;gt;product-&amp;gt;name ?&amp;gt;: $&amp;lt;?= $order_item-&amp;gt;price ?&amp;gt;
&amp;lt;?php endforeach; ?&amp;gt;
If you have any questions, feel free to respond to this email!
- Awesome Store
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;While we won’t modify the default text layout, please note that the default CakePHP layouts contain a message stating that the email was sent from the CakePHP framework. You can remove these if you like&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now that we have our email set, lets create a new event in our &lt;code&gt;app/config/events.php&lt;/code&gt; that we can use to send the email. We’ll call it &lt;code&gt;Order.postPurchase&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;use Cake\Network\Email\Email;
EventManager::instance()-&amp;gt;attach(function (Event $event) {
  $amount = $event-&amp;gt;data[&#39;amount&#39;];
  $order_items = $event-&amp;gt;data[&#39;order&#39;]-&amp;gt;order_items;
  $purchase_time = date(&#39;Y-m-d H:i:s&#39;);
  $user = $event-&amp;gt;data[&#39;user&#39;];
  $email = new Email();
  $email-&amp;gt;template(&#39;purchase&#39;, &#39;default&#39;)
      -&amp;gt;emailFormat(&#39;text&#39;)
      -&amp;gt;to($user[&#39;email&#39;])
      -&amp;gt;from(&#39;store@example.com&#39;)
      -&amp;gt;viewVars(compact(&#39;amount&#39;, &#39;order_items&#39;, &#39;purchase_time&#39;, &#39;user&#39;))
      -&amp;gt;send();
}, &#39;Order.postPurchase&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we’ll ensure we actually trigger this event in our &lt;code&gt;checkout&lt;/code&gt; action. Modify the bake &lt;code&gt;checkout.ctp&lt;/code&gt; element to include the following when the &lt;code&gt;$response-&amp;gt;isSuccessful()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$event = new \Cake\Event\Event(&#39;Order.postPurchase&#39;, $this, [
    &#39;amount&#39; =&amp;gt; $amount,
    &#39;order&#39; =&amp;gt; $order,
    &#39;user&#39; =&amp;gt; $this-&amp;gt;Auth-&amp;gt;user(),
]);
\Cake\Event\EventManager::instance()-&amp;gt;dispatch($event);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You’ll need configure your email settings in &lt;code&gt;app/config/app.php&lt;/code&gt;, but once you do, we will be sending users email whenever they’ve successfully completed a purchase! Note that now that we are using templates, we can &lt;em&gt;also&lt;/em&gt; use helpers as you would in any other template file, which allows you to build more complex emails and drive campaigns to users.&lt;/p&gt;

&lt;h2 id=&quot;homework-time&quot;&gt;Homework Time&lt;/h2&gt;

&lt;p&gt;You can actually do a few cool things with email - that I’ve done in other CakePHP websites and other frameworks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Log all emails to CLI and the Database when in Debug mode so that you can view what &lt;em&gt;would&lt;/em&gt; have been sent to a user instead of potentially spamming users. CakePHP allows you to build arbitrary Transport classes to make this possible.&lt;/li&gt;
  &lt;li&gt;Make a PostPurchaseEmail class that can take all it’s configuration within the constructor. This way you can simply instantiate that particular email class and let it worry about how it should configure the email.&lt;/li&gt;
  &lt;li&gt;Send both an html and a text representation of the same email. &lt;a href=&quot;http://templates.mailchimp.com/&quot;&gt;Mailchimp provides some templates&lt;/a&gt; you can model your email layouts after to get wider email client support.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Be sure to follow along via twitter on &lt;a href=&quot;https://twitter.com/savant&quot;&gt;@savant&lt;/a&gt;. If you’d like to subscribe to this blog, you may follow the &lt;a href=&quot;http://josediazgonzalez.com/atom.xml&quot;&gt;rss feed here&lt;/a&gt;. Also, all posts in the series will be conveniently linked on the sidebar of every post in the 2014 CakeAdvent Calendar. Come back tomorrow for more delicious content.&lt;/p&gt;

</description>
        <pubDate>Mon, 15 Dec 2014 13:42:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2014/12/15/sending-email-invoices-to-users-on-payment/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2014/12/15/sending-email-invoices-to-users-on-payment/</guid>
        
        <category>cakeadvent-2014</category>
        
        <category>cakephp</category>
        
        <category>email</category>
        
        <category>templates</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Processing Payments with CakePHP 3 and Omnipay</title>
        <description>&lt;p&gt;Today we’ll actually process a charge from our user - because making money is nice.&lt;/p&gt;

&lt;p&gt;As good PHP citizens, the CakePHP community does not re-implement existing libraries in the 3.x release - CakeTime with Carbon and the Migrations plugin with Phinx are good examples.&lt;/p&gt;

&lt;p&gt;Given the CakePHP philosophy, we’ll use the Omnipay library. Omnipay provides a single interface for each payment processor, allowing developers to create a process that works best for their developers.&lt;/p&gt;

&lt;p&gt;First, you’ll want to install Omnipay. We’ll be using stripe to process transactions, so install the omnipay adapter for that as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer require omnipay/omnipay
composer require omnipay/stripe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to also configure our stripe integration in our &lt;code&gt;app/config/app.php&lt;/code&gt; file. We’ll simply add our Stripe’s &lt;code&gt;api_key&lt;/code&gt; - found &lt;a href=&quot;https://dashboard.stripe.com/account/apikeys&quot;&gt;here&lt;/a&gt; - as so to the array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;    &#39;Stripe&#39; =&amp;gt; [
        // using the test keyS for now
        &#39;secret_key&#39; =&amp;gt; &#39;sk_test_SOME_KEY&#39;,
        &#39;publishable_key&#39; =&amp;gt; &#39;pk_test_SOME_KEY&#39;,
    ],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we’ll create a new action in our &lt;code&gt;orders&lt;/code&gt; page called &lt;code&gt;checkout&lt;/code&gt;. We’ll use bake again so that we can continue to add new actions without modifying the files themselves. Here is what our action - located in &lt;code&gt;src/Template/Bake/Element/Controller/checkout.ctp&lt;/code&gt; - will look like (see inline comments for details):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Checkout method
 *
 * @return void
 */
    public function checkout() {
        // Find the existing order
        $user_id = $this-&amp;gt;Auth-&amp;gt;user(&#39;id&#39;);
        $order = $this-&amp;gt;Orders-&amp;gt;find()
                        -&amp;gt;where([&#39;user_id&#39; =&amp;gt; $user_id])
                        -&amp;gt;contain([&#39;OrderItems&#39;])
                        -&amp;gt;first();
        // Redirect back to the cart if there is no order or any order items
        if (empty($order) || empty($order-&amp;gt;order_items)) {
            $this-&amp;gt;Flash-&amp;gt;error(__(&#39;No items in cart&#39;));
            return $this-&amp;gt;redirect([&#39;action&#39; =&amp;gt; &#39;cart&#39;]);
        }
        $amount = array_reduce($order-&amp;gt;order_items, function ($carry, $item) {
            return $carry + $item-&amp;gt;price;
        }, 0);
        $this-&amp;gt;set(compact(&#39;order&#39;, &#39;amount&#39;));
        if (!$this-&amp;gt;request-&amp;gt;is(&#39;post&#39;)) {
            return;
        }
        // Create an Omnipay Stripe gateway object and configure it
        $gateway = \Omnipay\Omnipay::create(&#39;Stripe&#39;);
        $gateway-&amp;gt;setApiKey(\Cake\Core\Configure::read(&#39;Stripe.secret_key&#39;));
        // Create a purchase with the stripe token and the amount in the cart
        $response = $gateway-&amp;gt;purchase([
            &#39;amount&#39; =&amp;gt; $amount,
            &#39;currency&#39; =&amp;gt; &#39;USD&#39;,
            &#39;token&#39; =&amp;gt; $this-&amp;gt;request-&amp;gt;data(&#39;Order.stripeToken&#39;)
        ])-&amp;gt;send();
        // Check to see if the purchase was successful
        if ($response-&amp;gt;isSuccessful()) {
            // Do something with the data
            \Cake\Log\Log::debug(json_encode($response-&amp;gt;getData()));
            $this-&amp;gt;Flash-&amp;gt;error(__(&#39;Payment successful!&#39;));
            return $this-&amp;gt;redirect([&#39;action&#39; =&amp;gt; &#39;cart&#39;]);
        } else {
            $this-&amp;gt;Flash-&amp;gt;error(__(&#39;Error processing payment: {0}&#39;, $response-&amp;gt;getMessage()));
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this will be our &lt;code&gt;src/Template/Bake/Template/checkout.ctp&lt;/code&gt; file. It’s a bit long, but basically it allows a user to submit a credit card to stripe without touching your servers, and then subsequently submits a token to your app that you can use to actually process a payment:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;div class=&quot;&amp;lt;%= $pluralVar %&amp;gt; form&quot;&amp;gt;
&amp;lt;?= $this-&amp;gt;Form-&amp;gt;create(null, [&#39;class&#39; =&amp;gt; &#39;payment-form&#39;]); ?&amp;gt;
    &amp;lt;fieldset&amp;gt;
        &amp;lt;legend&amp;gt;&amp;lt;?= __(&#39;Enter your details to submit the order ({0} total)&#39;, $amount) ?&amp;gt;&amp;lt;/legend&amp;gt;
        &amp;lt;span class=&quot;payment-errors&quot;&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;?= $this-&amp;gt;Form-&amp;gt;input(&#39;Order.number&#39;, [&#39;label&#39; =&amp;gt; &#39;Card Number&#39;]); ?&amp;gt;
        &amp;lt;?= $this-&amp;gt;Form-&amp;gt;input(&#39;Order.cvc&#39;, [&#39;label&#39; =&amp;gt; &#39;CVC&#39;]); ?&amp;gt;
        &amp;lt;?= $this-&amp;gt;Form-&amp;gt;input(&#39;Order.exp-month&#39;, [&#39;label&#39; =&amp;gt; &#39;Expiration Month (MM)&#39;]); ?&amp;gt;
        &amp;lt;?= $this-&amp;gt;Form-&amp;gt;input(&#39;Order.exp-year&#39;, [&#39;label&#39; =&amp;gt; &#39;Expiration Year (YYYY)&#39;]); ?&amp;gt;
    &amp;lt;/fieldset&amp;gt;
    &amp;lt;?= $this-&amp;gt;Form-&amp;gt;button(__(&#39;Submit Order&#39;)); ?&amp;gt;
&amp;lt;?= $this-&amp;gt;Form-&amp;gt;end(); ?&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://code.jquery.com/jquery-1.10.2.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://js.stripe.com/v2/&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
// The JS needs access to the publishable stripe key
Stripe.setPublishableKey(&#39;&amp;lt;?php echo \Cake\Core\Configure::read(&#39;Stripe.publishable_key&#39;); ?&amp;gt;&#39;);
// We need to create a callback to process the stripe payement, as
// well as show errors or submit the token in case of success.
var stripeResponseHandler = function(status, response) {
  var $form = $(&#39;.payment-form&#39;);
  if (response.error) {
    // Show the errors on the form
    $form.find(&#39;.payment-errors&#39;).text(response.error.message);
    $form.find(&#39;button&#39;).prop(&#39;disabled&#39;, false);
  } else {
    // token contains id, last4, and card type
    var token = response.id;
    // Reset form data we do not want to submit to the server
    $(&#39;#order-number, #order-cvc, #order-exp-month, #order-xp-year&#39;).val(&quot;&quot;);
    // Insert the token into the form so it gets submitted to the server
    $form.append($(&#39;&amp;lt;input type=&quot;hidden&quot; name=&quot;Order[stripeToken]&quot; /&amp;gt;&#39;).val(token));
    // and submit
    $form.get(0).submit();
  }
};
jQuery(function($) {
  $(&#39;.payment-form&#39;).submit(function(e) {
    // Prevent the form from submitting with the default action
    e.preventDefault();
    var $form = $(this);
    // Disable the submit button to prevent repeated clicks
    $form.find(&#39;button&#39;).prop(&#39;disabled&#39;, true);
    Stripe.card.createToken({
      number: $(&#39;#order-number&#39;).val(),
      cvc: $(&#39;#order-cvc&#39;).val(),
      exp_month: $(&#39;#order-exp-month&#39;).val(),
      exp_year: $(&#39;#order-exp-year&#39;).val()
    }, stripeResponseHandler);
  });
});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to tell bake to create these this action and it’s related template in our &lt;code&gt;app/config/bootstrap_cli.php&lt;/code&gt;. The actions for the &lt;code&gt;Orders&lt;/code&gt; controller should look something like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;if ($isController &amp;amp;&amp;amp; $name == &#39;Orders&#39;) {
    $view-&amp;gt;viewVars[&#39;actions&#39;] = [&#39;cart&#39;, &#39;checkout&#39;];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can now rebake the controller and templates for the OrdersController:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd /vagrant/app
bin/cake bake controller orders -f
bin/cake bake view orders -f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming you are using test credentials, you can use the card number &lt;code&gt;4242424242424242&lt;/code&gt; with any CVC and a valid expiration date to successfully complete a purchase.&lt;/p&gt;

&lt;h2 id=&quot;homework-time&quot;&gt;Homework Time!&lt;/h2&gt;

&lt;p&gt;While our cart is getting there - only two more posts to go! - we still need to add a few features to actually complete the transaction process. These features are strictly up to you to implement, though I’ve included pointers where necessary:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Store the response from stripe in our database. I would create a &lt;code&gt;payments&lt;/code&gt; table and store all the data related to an order payment there.&lt;/li&gt;
  &lt;li&gt;Mark an order as “paid”. Once paid, we can then do any extra processing necessary. Perhaps trigger a Cake Event that we can use to handle the actual “shipping” of products.&lt;/li&gt;
  &lt;li&gt;Ensure that user’s don’t accidentally pay twice. We can do this by making any retrieval of the &lt;code&gt;Order&lt;/code&gt; require that an order be in a &lt;code&gt;pending&lt;/code&gt; state (and make all orders pending by default). You can quite easily write a migration for this.&lt;/li&gt;
  &lt;li&gt;Add a &lt;em&gt;Successful Payment&lt;/em&gt; page that we redirect to once payment has been made.&lt;/li&gt;
  &lt;li&gt;Add an Order status page, as well as a page to view all of a user’s orders.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Be sure to follow along via twitter on &lt;a href=&quot;https://twitter.com/savant&quot;&gt;@savant&lt;/a&gt;. If you’d like to subscribe to this blog, you may follow the &lt;a href=&quot;http://josediazgonzalez.com/atom.xml&quot;&gt;rss feed here&lt;/a&gt;. Also, all posts in the series will be conveniently linked on the sidebar of every post in the 2014 CakeAdvent Calendar. Come back tomorrow for more delicious content.&lt;/p&gt;

</description>
        <pubDate>Sun, 14 Dec 2014 17:26:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2014/12/14/processing-payments-with-cakephp-3/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2014/12/14/processing-payments-with-cakephp-3/</guid>
        
        <category>cakeadvent-2014</category>
        
        <category>cakephp</category>
        
        <category>composer</category>
        
        <category>payments</category>
        
        <category>stripe</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Building a user cart system in CakePHP</title>
        <description>&lt;p&gt;Today’s post will be fairly straightforward. We should now have dummy data in our application, can browse products, and authenticate as users to actually start using our store. So lets allow people to add items to their carts.&lt;/p&gt;

&lt;p&gt;First thing we’ll need is to customize the methods available to the Products controller. We already have a bake event in our &lt;code&gt;app/config/bootstrap_cli.php&lt;/code&gt;, so we’ll add the following bit of code to limit the actions (as well as add two new ones);&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;if ($isController &amp;amp;&amp;amp; $name == &#39;Products&#39;) {
    $view-&amp;gt;viewVars[&#39;actions&#39;] = [&#39;index&#39;, &#39;view&#39;, &#39;add&#39;, &#39;addToCart&#39;, &#39;removeFromCart&#39;];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we’ll create two new bake controller elements in our &lt;code&gt;src/Template/Bake/Element/Controller&lt;/code&gt; directory. One will be our &lt;code&gt;addToCart.ctp&lt;/code&gt; file, and the other will be &lt;code&gt;removeFromCart.ctp&lt;/code&gt;. This is our &lt;code&gt;addToCart.ctp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Add to cart method
 *
 * @param string|null $id &amp;lt;%= $singularHumanName %&amp;gt; id
 * @return void
 * @throws \Cake\Network\Exception\NotFoundException
 */
    public function addToCart($id = null) {
        $&amp;lt;%= $singularName%&amp;gt; = $this-&amp;gt;&amp;lt;%= $currentModelName %&amp;gt;-&amp;gt;get($id);
        $event = new \Cake\Event\Event(&#39;Order.addToCart&#39;, $this, [
            &#39;&amp;lt;%= $singularName%&amp;gt;&#39; =&amp;gt; $&amp;lt;%= $singularName%&amp;gt;,
            &#39;user&#39; =&amp;gt; $this-&amp;gt;Auth-&amp;gt;user(),
        ]);
        \Cake\Event\EventManager::instance()-&amp;gt;dispatch($event);
        if ($event-&amp;gt;result) {
            $this-&amp;gt;Flash-&amp;gt;success(&#39;The &amp;lt;%= $singularName%&amp;gt; has been added to your cart.&#39;);
        } else {
            $this-&amp;gt;Flash-&amp;gt;error(&#39;The &amp;lt;%= $singularName%&amp;gt; could not be added to your cart.&#39;);
        }
        return $this-&amp;gt;redirect($this-&amp;gt;referer());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is our &lt;code&gt;removeFromCart.ctp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Remove from cart method
 *
 * @param string|null $id &amp;lt;%= $singularHumanName %&amp;gt; id
 * @return void
 * @throws \Cake\Network\Exception\NotFoundException
 */
    public function removeFromCart($id = null) {
        $&amp;lt;%= $singularName%&amp;gt; = $this-&amp;gt;&amp;lt;%= $currentModelName %&amp;gt;-&amp;gt;get($id);
        $event = new \Cake\Event\Event(&#39;Order.removeFromCart&#39;, $this, [
            &#39;&amp;lt;%= $singularName%&amp;gt;&#39; =&amp;gt; $&amp;lt;%= $singularName%&amp;gt;,
            &#39;user&#39; =&amp;gt; $this-&amp;gt;Auth-&amp;gt;user(),
        ]);
        \Cake\Event\EventManager::instance()-&amp;gt;dispatch($event);
        if ($event-&amp;gt;result) {
            $this-&amp;gt;Flash-&amp;gt;success(&#39;The &amp;lt;%= $singularName%&amp;gt; has been removed from your cart.&#39;);
        } else {
            $this-&amp;gt;Flash-&amp;gt;error(&#39;The &amp;lt;%= $singularName%&amp;gt; could not be removed from your cart.&#39;);
        }
        return $this-&amp;gt;redirect($this-&amp;gt;referer());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few notes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We’re using events to add and remove items from our cart. Some people would call table/entity methods directly, but we’re doing this to keep our actions flexible.&lt;/li&gt;
  &lt;li&gt;We use the &lt;code&gt;Table::get()&lt;/code&gt; method which may return a &lt;code&gt;NotFoundException&lt;/code&gt;. If a user tries to add an invalid product to their cart, we should signal such using the Application’s configured Error Handler.&lt;/li&gt;
  &lt;li&gt;We aren’t handling adding multiple of the same product to our cart just yet. If you’d like to, please modify your templates, but we’re keeping our cart simple.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We now need to add one of these actions to our &lt;code&gt;/products/index&lt;/code&gt; page. We’ll need to first copy over the core &lt;code&gt;index.ctp&lt;/code&gt; so we can modify it a bit:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;TEMPLATE_DIR=&quot;src/Template/Bake/&quot;
BAKE_TEMPLATE_DIR=&quot;vendor/cakephp/cakephp/src/Template/Bake/&quot;
cd /vagrant/app
cp $BAKE_TEMPLATE_DIR/Template/index.ctp $TEMPLATE_DIR/Template/index.ctp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our new &lt;code&gt;src/Template/Bake/Template/index.ctp&lt;/code&gt; does not take a list of related actions to perform on an item, so we’re going to add this. Around line 86, you’ll see a chunk of code that looks like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;td class=&quot;actions&quot;&amp;gt;
    &amp;lt;?= $this-&amp;gt;Html-&amp;gt;link(__(&#39;View&#39;), [&#39;action&#39; =&amp;gt; &#39;view&#39;, &amp;lt;%= $pk %&amp;gt;]) ?&amp;gt;
    &amp;lt;?= $this-&amp;gt;Html-&amp;gt;link(__(&#39;Edit&#39;), [&#39;action&#39; =&amp;gt; &#39;edit&#39;, &amp;lt;%= $pk %&amp;gt;]) ?&amp;gt;
    &amp;lt;?= $this-&amp;gt;Form-&amp;gt;postLink(__(&#39;Delete&#39;), [&#39;action&#39; =&amp;gt; &#39;delete&#39;, &amp;lt;%= $pk %&amp;gt;], [&#39;confirm&#39; =&amp;gt; __(&#39;Are you sure you want to delete # {0}?&#39;, &amp;lt;%= $pk %&amp;gt;)]) ?&amp;gt;
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We’re going to replace it with the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;td class=&quot;actions&quot;&amp;gt;
    &amp;lt;% foreach ($singularActions as $config) : %&amp;gt;
        &amp;lt;?= $this-&amp;gt;Html-&amp;gt;link(__(&#39;&amp;lt;%= $config[&#39;title&#39;] %&amp;gt;&#39;), [&#39;action&#39; =&amp;gt; &#39;&amp;lt;%= $config[&#39;action&#39;] %&amp;gt;&#39;, &amp;lt;%= $pk %&amp;gt;]) ?&amp;gt;
    &amp;lt;% endforeach; %&amp;gt;
    &amp;lt;% foreach ($singularConfirmActions as $config) : %&amp;gt;
        &amp;lt;?= $this-&amp;gt;Form-&amp;gt;postLink(__(&#39;&amp;lt;%= $config[&#39;title&#39;] %&amp;gt;&#39;), [&#39;action&#39; =&amp;gt; &#39;&amp;lt;%= $config[&#39;action&#39;] %&amp;gt;&#39;, &amp;lt;%= $pk %&amp;gt;], [&#39;confirm&#39; =&amp;gt; __(&#39;&amp;lt;%= $config[&#39;message&#39;] %&amp;gt;&#39;, &amp;lt;%= $pk %&amp;gt;)) ?&amp;gt;
    &amp;lt;% endforeach; %&amp;gt;
&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the modified template, we’re removing the hardcoded list of actions displayed and introducing two new variables, &lt;code&gt;singularActions&lt;/code&gt; and &lt;code&gt;singularConfirmActions&lt;/code&gt;. These will act upon a single item listed on the index page. We’ll configure them in our &lt;code&gt;app/config/bootstrap_cli.php&lt;/code&gt; with the following new event:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;EventManager::instance()-&amp;gt;attach(function (Event $event) {
    $view = $event-&amp;gt;subject;
    $name = Hash::get($view-&amp;gt;viewVars, &#39;pluralHumanName&#39;);
    $isIndexView = strpos($event-&amp;gt;data[0], &#39;Bake/Template/index.ctp&#39;) !== false;
    if ($isIndexView) {
        $singularActions = [
            [&#39;action&#39; =&amp;gt; &#39;view&#39;, &#39;title&#39; =&amp;gt; &#39;View&#39;],
            [&#39;action&#39; =&amp;gt; &#39;edit&#39;, &#39;title&#39; =&amp;gt; &#39;Edit&#39;],
        ];
        $singularConfirmActions = [
            [&#39;action&#39; =&amp;gt; &#39;delete&#39;, &#39;title&#39; =&amp;gt; &#39;Delete&#39;, &#39;message&#39; =&amp;gt; &#39;Are you sure you want to delete # {0}?&#39;],
        ];
        if ($name == &#39;Products&#39;) {
            $singularActions = [
                [&#39;action&#39; =&amp;gt; &#39;view&#39;, &#39;title&#39; =&amp;gt; &#39;View&#39;],
                [&#39;action&#39; =&amp;gt; &#39;addToCart&#39;, &#39;title&#39; =&amp;gt; &#39;Add To Cart&#39;],
            ];
            $singularConfirmActions = [];
        }
        $view-&amp;gt;viewVars[&#39;singularActions&#39;] = $singularActions;
        $view-&amp;gt;viewVars[&#39;singularConfirmActions&#39;] = $singularConfirmActions;
    }
}, &#39;Bake.beforeRender&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above event will allow us to keep all other baked &lt;code&gt;index.ctp&lt;/code&gt; template output the same, while allowing us to hijack the actions listed for the &lt;code&gt;Products&lt;/code&gt; view to show our &lt;code&gt;Add To Cart&lt;/code&gt; link.&lt;/p&gt;

&lt;p&gt;Finally, we will need to actually handle processing of our events. We’ll create an &lt;code&gt;app/config/events.php&lt;/code&gt; and include it on our &lt;code&gt;app/config/bootstrap.php&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;require __DIR__ . &#39;/events.php&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need two events, one to manage adding a product to the user’s cart, and one to manage removing the product from a user’s cart. We’ll have the user’s session at hand, as well as the product entity. Here is what our &lt;code&gt;Order.addToCart&lt;/code&gt; event will look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;EventManager::instance()-&amp;gt;attach(function (Event $event) {
    $data = $event-&amp;gt;data;
    if (empty($data[&#39;user&#39;])) {
        // User is not logged in
        return $event-&amp;gt;result = false;
    }
    if (empty($data[&#39;product&#39;])) {
        // Invalid product specified
        return $event-&amp;gt;result = false;
    }
    $user = $data[&#39;user&#39;];
    $product = $data[&#39;product&#39;];
    if ($product-&amp;gt;stock &amp;lt;= 0) {
        // No more stock for product
        return $event-&amp;gt;result = false;
    }
    $Orders = TableRegistry::get(&#39;Orders&#39;);
    $order = $Orders-&amp;gt;find()
                    -&amp;gt;where([&#39;user_id&#39; =&amp;gt; $user[&#39;id&#39;]])
                    -&amp;gt;first();
    if (empty($order)) {
        // Create a new order where necessary
        $order = $Orders-&amp;gt;newEntity([&#39;user_id&#39; =&amp;gt; $user[&#39;id&#39;]]);
        $order = $Orders-&amp;gt;save($order);
    }
    $OrderItems = TableRegistry::get(&#39;OrderItems&#39;);
    $orderItem = $OrderItems-&amp;gt;newEntity([
        &#39;order_id&#39; =&amp;gt; $order-&amp;gt;id,
        &#39;product_id&#39; =&amp;gt; $product-&amp;gt;id,
        &#39;quantity&#39; =&amp;gt; 1,
        &#39;price&#39; =&amp;gt; $product-&amp;gt;price,
    ]);
    // Save the order item entry
    if (!$OrderItems-&amp;gt;save($orderItem)) {
        return $event-&amp;gt;result = false;
    }
    // Decrease the amount of stock
    $Products = TableRegistry::get(&#39;Products&#39;);
    $product-&amp;gt;stock--;
    return $event-&amp;gt;result = !!$Products-&amp;gt;save($product);
}, &#39;Order.addToCart&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And our equally-well commented &lt;code&gt;Order.removeFromCart&lt;/code&gt; event:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;EventManager::instance()-&amp;gt;attach(function (Event $event) {
    $data = $event-&amp;gt;data;
    if (empty($data[&#39;user&#39;])) {
        // User is not logged in
        return $event-&amp;gt;result = false;
    }
    if (empty($data[&#39;product&#39;])) {
        // Invalid product specified
        return $event-&amp;gt;result = false;
    }
    $user = $data[&#39;user&#39;];
    $product = $data[&#39;product&#39;];
    $Orders = TableRegistry::get(&#39;Orders&#39;);
    $order = $Orders-&amp;gt;find()
                    -&amp;gt;where([&#39;user_id&#39; =&amp;gt; $user[&#39;id&#39;]])
                    -&amp;gt;first();
    if (empty($order)) {
        // There is no cart associated with the user
        return $event-&amp;gt;result = false;
    }
    $OrderItems = TableRegistry::get(&#39;OrderItems&#39;);
    $orderItem = $OrderItems-&amp;gt;find()
                            -&amp;gt;where([&#39;order_id&#39; =&amp;gt; $order-&amp;gt;id, &#39;product_id&#39; =&amp;gt; $product-&amp;gt;id])
                            -&amp;gt;first();
    if (empty($orderItem)) {
        // Item not in user&#39;s cart
        return $event-&amp;gt;result = false;
    }
    if (!$OrderItems-&amp;gt;delete($orderItem)) {
        // Unable to remove item from cart
        return $event-&amp;gt;result = false;
    }
    // Increase product stock
    $Products = TableRegistry::get(&#39;Products&#39;);
    $product-&amp;gt;stock++;
    return $event-&amp;gt;result = !!$Products-&amp;gt;save($product);
}, &#39;Order.removeFromCart&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;A real ecommerce solution will have much more stringent protocols surrounding adding/removing stock from a product. We’re doing it this way because it’s much simpler than going through the rabbit-hole, but please keep this in mind if you are building out your own solution for a customer. For instance, consider doing all table manipulation using a transaction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One last thing. We’ll want a new action to list all the items in a user’s order, as well as a way to actually call our &lt;code&gt;/products/removeFromCart&lt;/code&gt; action. We’ll define a new Controller bake template in &lt;code&gt;src/Template/Bake/Element/Controller/cart.ctp&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Cart method
 *
 * @return void
 */
    public function cart() {
        $user_id = $this-&amp;gt;Auth-&amp;gt;user(&#39;id&#39;);
        $&amp;lt;%= $singularName%&amp;gt; = $this-&amp;gt;&amp;lt;%= $currentModelName %&amp;gt;-&amp;gt;find()
                        -&amp;gt;where([&#39;user_id&#39; =&amp;gt; $user_id])
                        -&amp;gt;first();
        if (empty($&amp;lt;%= $singularName%&amp;gt;)) {
            $&amp;lt;%= $singularName%&amp;gt; = $this-&amp;gt;&amp;lt;%= $currentModelName %&amp;gt;-&amp;gt;newEntity([&#39;user_id&#39; =&amp;gt; $user_id]);
            $&amp;lt;%= $singularName%&amp;gt; = $this-&amp;gt;&amp;lt;%= $currentModelName %&amp;gt;-&amp;gt;save($&amp;lt;%= $singularName%&amp;gt;);
        }
        $items = $this-&amp;gt;&amp;lt;%= $currentModelName %&amp;gt;-&amp;gt;OrderItems-&amp;gt;find()
                                  -&amp;gt;where([&#39;order_id&#39; =&amp;gt; $&amp;lt;%= $singularName%&amp;gt;-&amp;gt;id])
                                  -&amp;gt;contain([&#39;Products&#39;])
                                  -&amp;gt;all();
        $this-&amp;gt;set(compact(&#39;&amp;lt;%= $singularName%&amp;gt;&#39;, &#39;items&#39;));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we’ll restrict our &lt;code&gt;Orders&lt;/code&gt; controller to just this action in our &lt;code&gt;app/config/bootstrap_cli.php&lt;/code&gt; with the following check:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;if ($isController &amp;amp;&amp;amp; $name == &#39;Orders&#39;) {
    $view-&amp;gt;viewVars[&#39;actions&#39;] = [&#39;cart&#39;];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And our simple &lt;code&gt;src/Template/Bake/Template/cart.ctp&lt;/code&gt; will be the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;orders index large-10 medium-9 columns&quot;&amp;gt;
    &amp;lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&amp;gt;
        &amp;lt;thead&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;Quantity&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;Price&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;Actions&amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;
        &amp;lt;/thead&amp;gt;
        &amp;lt;tbody&amp;gt;
            &amp;lt;?php foreach ($items as $item) : ?&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;?= $item-&amp;gt;product-&amp;gt;name ?&amp;gt;&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;?= $item-&amp;gt;quantity ?&amp;gt;&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;&amp;lt;?= $item-&amp;gt;price ?&amp;gt;&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;
                    &amp;lt;?= $this-&amp;gt;Html-&amp;gt;link(__(&#39;View&#39;), [&#39;controller&#39; =&amp;gt; &#39;Products&#39;, &#39;action&#39; =&amp;gt; &#39;view&#39;, $item-&amp;gt;product_id]) ?&amp;gt;
                    &amp;lt;?= $this-&amp;gt;Html-&amp;gt;link(__(&#39;Remove from Cart&#39;), [&#39;controller&#39; =&amp;gt; &#39;Products&#39;, &#39;action&#39; =&amp;gt; &#39;removeFromCart&#39;, $item-&amp;gt;product_id]) ?&amp;gt;
                &amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;?php endforeach; ?&amp;gt;
        &amp;lt;/tbody&amp;gt;
    &amp;lt;/table&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can &lt;em&gt;now&lt;/em&gt; run bake to recreate the respective controllers and templates and we should have a reasonable cart system!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd /vagrant/app
bin/cake bake controller orders -f
bin/cake bake controller products -f
bin/cake bake view orders -f
bin/cake bake view products -f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can access your cart by going to &lt;code&gt;/orders/cart&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;homework-time&quot;&gt;Homework Time&lt;/h2&gt;

&lt;p&gt;Your homework today is as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Remove all those extra pesky actions on the index page&lt;/li&gt;
  &lt;li&gt;Add a button to add products to your cart from the product view page&lt;/li&gt;
  &lt;li&gt;Link to the cart in your header (checkout your &lt;code&gt;src/Template/Layout/default.ctp&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Add a custom route for &lt;code&gt;/orders/cart&lt;/code&gt; to be &lt;code&gt;/cart&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Add a &lt;code&gt;total&lt;/code&gt; to your cart page.&lt;/li&gt;
  &lt;li&gt;Require that user’s be authenticated before adding/removing/viewing their cart&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Be sure to follow along via twitter on &lt;a href=&quot;https://twitter.com/savant&quot;&gt;@savant&lt;/a&gt;. If you’d like to subscribe to this blog, you may follow the &lt;a href=&quot;http://josediazgonzalez.com/atom.xml&quot;&gt;rss feed here&lt;/a&gt;. Also, all posts in the series will be conveniently linked on the sidebar of every post in the 2014 CakeAdvent Calendar. Come back tomorrow for more delicious content.&lt;/p&gt;

</description>
        <pubDate>Sat, 13 Dec 2014 17:26:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2014/12/13/building-a-user-cart-system-in-cakephp/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2014/12/13/building-a-user-cart-system-in-cakephp/</guid>
        
        <category>cakeadvent-2014</category>
        
        <category>cakephp</category>
        
        <category>composer</category>
        
        <category>cart management</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Adding dummy data via a custom faker shell to our store</title>
        <description>&lt;p&gt;The excellent &lt;a href=&quot;http://jadb.io&quot;&gt;Jad Bittar&lt;/a&gt; added support for Faker to the Cake3 ORM as a plugin, so we can use this to generate dummy data for our application. This will allow us to easily test stuff going forward. Let’s start by installing the plugin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;composer require gourmet/faker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will pull in both the CakePHP plugin as well as the Faker library. Next, lets generate a shell to generate dummy data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd /vagrant/app

# generate a dummy data shell
bin/cake bake shell DummyData
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new shell will be created in &lt;code&gt;app/src/Shell/DummyDataShell.php&lt;/code&gt;. It has a &lt;code&gt;main&lt;/code&gt; method which you can modify, and if you run the following command now:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bin/cake dummy_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You’ll have the following - pretty plain - output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@precise32:/vagrant/app$ bin/cake dummy_data

Welcome to CakePHP v3.0.0-beta3 Console
---------------------------------------------------------------
App : src
Path: /vagrant/app/src/
---------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets actually do something with this new shell. In our &lt;code&gt;DummyDataShell::main()&lt;/code&gt; method, we’ll need to create a &lt;code&gt;faker&lt;/code&gt; object&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$faker = \Faker\Factory::create();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Faker uses providers to give custom data types to fields. We’ll first populate the &lt;code&gt;users&lt;/code&gt; table, and to do so, we’ll need to provide fake email addresses. To do so, we’ll need to add the &lt;code&gt;Internet&lt;/code&gt; provider:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$faker-&amp;gt;addProvider(new \Faker\Provider\Internet($faker));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To populate a specific type of entity, we need to create an EntityPopulator object. The Faker library provides a custom populator for the CakePHP framework, which we’ll leverage in our case. You simply need to provide the name of the table class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$entityPopulator = new \Faker\ORM\CakePHP\EntityPopulator(&#39;Users&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we need to create a populator object that will actually insert data into the database. We need to pass in our EntityPopulator object, a number of records to insert, as well as custom formatters. The formatters come from providers - we added the &lt;code&gt;Internet&lt;/code&gt; provider above - or your own text. Faker tries to autodetect data types, but will default to stuff like &lt;code&gt;plaintext&lt;/code&gt; for &lt;code&gt;email&lt;/code&gt; fields, so we need to override this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$populator = new \Faker\ORM\CakePHP\Populator($faker);
$populator-&amp;gt;addEntity($entityPopulator, 20, [
  &#39;email&#39; =&amp;gt; function () use ($faker) { return $faker-&amp;gt;email(); },
  &#39;password&#39; =&amp;gt; &#39;password&#39;,
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last thing is to actually populate our table!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$populator-&amp;gt;execute([&#39;validate&#39; =&amp;gt; false]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full code sample will look like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$this-&amp;gt;out(&quot;Creating user populator&quot;);
$faker = \Faker\Factory::create();
$faker-&amp;gt;addProvider(new \Faker\Provider\Internet($faker));

$entityPopulator = new \Faker\ORM\CakePHP\EntityPopulator(&#39;Users&#39;);
$populator = new \Faker\ORM\CakePHP\Populator($faker);
$populator-&amp;gt;addEntity($entityPopulator, 20, [
  &#39;email&#39; =&amp;gt; function () use ($faker) { return $faker-&amp;gt;email(); },
  &#39;password&#39; =&amp;gt; &#39;password&#39;,
]);

$this-&amp;gt;out(&quot;Inserting&quot;);
$populator-&amp;gt;execute([&#39;validate&#39; =&amp;gt; false]);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;I’ve added some calls to &lt;code&gt;$this-&amp;gt;out()&lt;/code&gt; to provide feedback in my shell. You can omit these or add more as you like. This is a special helper method available in shells&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you run this, you’ll recieve the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant@precise32:/vagrant/app$ bin/cake dummy_data

Welcome to CakePHP v3.0.0-beta3 Console
---------------------------------------------------------------
App : src
Path: /vagrant/app/src/
---------------------------------------------------------------
Creating user populator
Inserting
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But more importantly, you’ll have 20 beautiful user records with passwords. You should be able to login as any of these users.&lt;/p&gt;

&lt;h2 id=&quot;homework-time&quot;&gt;Homework time!&lt;/h2&gt;

&lt;p&gt;If you thought you’d get off this week, you thought incorrectly. Your homework is to create dummy data for every model we have in our app - a store without products is kind of useless. You can ignore the &lt;code&gt;Orders&lt;/code&gt; and &lt;code&gt;OrderItems&lt;/code&gt; models.&lt;/p&gt;
</description>
        <pubDate>Fri, 12 Dec 2014 18:26:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2014/12/12/adding-dummy-data-to-our-store/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2014/12/12/adding-dummy-data-to-our-store/</guid>
        
        <category>cakeadvent-2014</category>
        
        <category>cakephp</category>
        
        <category>composer</category>
        
        
        <category>cakephp</category>
        
      </item>
    
      <item>
        <title>Adding an Authentication layer to our CakePHP Store</title>
        <description>&lt;p&gt;We already have basic scaffolding for our application, so lets get authentication working. First, we’ll add the login/logout methods by modifying our bake skeleton. Add the following to your &lt;code&gt;app/config/bootstrap_cli.php&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;use Cake\Event\Event;
use Cake\Event\EventManager;
use Cake\Utility\Hash;

EventManager::instance()-&amp;gt;attach(function (Event $event) {
    $view = $event-&amp;gt;subject;
    $name = Hash::get($view-&amp;gt;viewVars, &#39;name&#39;);
    $isController = strpos($event-&amp;gt;data[0], &#39;Bake/Controller/controller.ctp&#39;) !== false;
    if ($isController &amp;amp;&amp;amp; $name == &#39;Users&#39;) {
        $view-&amp;gt;viewVars[&#39;actions&#39;] = [&#39;login&#39;, &#39;logout&#39;, &#39;index&#39;, &#39;view&#39;, &#39;register&#39;, &#39;edit&#39;, &#39;delete&#39;];
    }
}, &#39;Bake.beforeRender&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that this is set, we’ll need action templates for our &lt;code&gt;login&lt;/code&gt;, &lt;code&gt;logout&lt;/code&gt;, and &lt;code&gt;register&lt;/code&gt; methods. These do not come with CakePHP as they can be pretty specific, so we’ll include some pretty basic ones.&lt;/p&gt;

&lt;p&gt;Here is &lt;code&gt;app/src/Template/Bake/Element/Controller/login.ctp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;/**
 * Login method
 *
 * @return void
 */
public function login() {
    if ($this-&amp;gt;request-&amp;gt;is(&#39;post&#39;)) {
        $user = $this-&amp;gt;Auth-&amp;gt;identify();
        if ($user) {
            $this-&amp;gt;Auth-&amp;gt;setUser($user);
            return $this-&amp;gt;redirect($this-&amp;gt;Auth-&amp;gt;redirectUrl());
        }
        $this-&amp;gt;Flash-&amp;gt;error(__(&#39;Invalid username or password, try again&#39;));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is &lt;code&gt;app/src/Template/Bake/Element/Controller/logout.ctp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;/**
 * Logout method
 *
 * @return void
 */
public function logout() {
    return $this-&amp;gt;redirect($this-&amp;gt;Auth-&amp;gt;logout());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally &lt;code&gt;app/src/Template/Bake/Element/Controller/register.ctp&lt;/code&gt; (which is simply &lt;code&gt;add.ctp&lt;/code&gt; but with the action name changed):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;% $compact = [&quot;&#39;&quot; . $singularName . &quot;&#39;&quot;]; %&amp;gt;

/**
 * Register method
 *
 * @return void
 */
  public function register() {
    $&amp;lt;%= $singularName %&amp;gt; = $this-&amp;gt;&amp;lt;%= $currentModelName %&amp;gt;-&amp;gt;newEntity($this-&amp;gt;request-&amp;gt;data);
    if ($this-&amp;gt;request-&amp;gt;is(&#39;post&#39;)) {
      if ($this-&amp;gt;&amp;lt;%= $currentModelName; %&amp;gt;-&amp;gt;save($&amp;lt;%= $singularName %&amp;gt;)) {
        $this-&amp;gt;Flash-&amp;gt;success(&#39;The &amp;lt;%= strtolower($singularHumanName) %&amp;gt; has been saved.&#39;);
        return $this-&amp;gt;redirect([&#39;action&#39; =&amp;gt; &#39;index&#39;]);
      } else {
        $this-&amp;gt;Flash-&amp;gt;error(&#39;The &amp;lt;%= strtolower($singularHumanName) %&amp;gt; could not be saved. Please, try again.&#39;);
      }
    }
&amp;lt;%
    $associations = array_merge(
      $this-&amp;gt;Bake-&amp;gt;aliasExtractor($modelObj, &#39;BelongsTo&#39;),
      $this-&amp;gt;Bake-&amp;gt;aliasExtractor($modelObj, &#39;BelongsToMany&#39;)
    );
    foreach ($associations as $assoc):
      $association = $modelObj-&amp;gt;association($assoc);
      $otherName = $association-&amp;gt;target()-&amp;gt;alias();
      $otherPlural = $this-&amp;gt;_variableName($otherName);
%&amp;gt;
    $&amp;lt;%= $otherPlural %&amp;gt; = $this-&amp;gt;&amp;lt;%= $currentModelName %&amp;gt;-&amp;gt;&amp;lt;%= $otherName %&amp;gt;-&amp;gt;find(&#39;list&#39;);
&amp;lt;%
      $compact[] = &quot;&#39;$otherPlural&#39;&quot;;
    endforeach;
%&amp;gt;
    $this-&amp;gt;set(compact(&amp;lt;%= join(&#39;, &#39;, $compact) %&amp;gt;));
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can rebake your UsersController now:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd /vagrant/app

bin/cake bake controller users -f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need a login view template at &lt;code&gt;app/src/Template/Bake/Template/login.ctp&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;div class=&quot;&amp;lt;%= $pluralVar %&amp;gt; form&quot;&amp;gt;
&amp;lt;?= $this-&amp;gt;Flash-&amp;gt;render(&#39;auth&#39;) ?&amp;gt;
&amp;lt;?= $this-&amp;gt;Form-&amp;gt;create() ?&amp;gt;
    &amp;lt;fieldset&amp;gt;
        &amp;lt;legend&amp;gt;&amp;lt;?= __(&#39;Please enter your username and password&#39;) ?&amp;gt;&amp;lt;/legend&amp;gt;
        &amp;lt;?= $this-&amp;gt;Form-&amp;gt;input(&#39;username&#39;) ?&amp;gt;
        &amp;lt;?= $this-&amp;gt;Form-&amp;gt;input(&#39;password&#39;) ?&amp;gt;
    &amp;lt;/fieldset&amp;gt;
&amp;lt;?= $this-&amp;gt;Form-&amp;gt;button(__(&#39;Login&#39;)); ?&amp;gt;
&amp;lt;?= $this-&amp;gt;Form-&amp;gt;end() ?&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we need our &lt;code&gt;app/src/Template/Bake/Template/register.ctp&lt;/code&gt;, which will just call out to the &lt;code&gt;form.ctp&lt;/code&gt; element:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;%
echo $this-&amp;gt;element(&#39;form&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create these new views, we can simply use bake. Note that if a bake template does not exist for a given action, a corresponding view template is not created. This means we won’t have an empty &lt;code&gt;app/src/Template/Users/logout.ctp&lt;/code&gt; generated, which is nice.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bin/cake bake view users -f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When users register themselves, we want to ensure they have correct data in the database. CakePHP exposes Validators for this exact purpose, and we’ll add a custom validator to our &lt;code&gt;UsersTable&lt;/code&gt; to handle this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// Also include `use Cake\Validation\Validator;` at the top of your class
public function validationDefault(Validator $validator) {
    return $validator
        -&amp;gt;notEmpty(&#39;username&#39;, &#39;A username is required&#39;)
        -&amp;gt;notEmpty(&#39;password&#39;, &#39;A password is required&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;We’ll go into Validators in more detail in a future post. For now, just be aware that they exist and can be used on any type of data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;While we’ve templated out a bunch of stuff, we still need to actually handle login/logout. You can load the AuthComponent in your AppController::initialize() like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;public function initialize() {
    $this-&amp;gt;loadComponent(&#39;Flash&#39;);
    $this-&amp;gt;loadComponent(&#39;Auth&#39;, [
        // Where to redirect after a successful login
        &#39;loginRedirect&#39; =&amp;gt; [
            &#39;controller&#39; =&amp;gt; &#39;Products&#39;,
            &#39;action&#39; =&amp;gt; &#39;index&#39;
        ],
        // Where to redirect after a user logs out
        &#39;logoutRedirect&#39; =&amp;gt; [
            &#39;controller&#39; =&amp;gt; &#39;Products&#39;,
            &#39;action&#39; =&amp;gt; &#39;index&#39;,
            &#39;home&#39;
        ]
    ]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In previous CakePHP versions, you would use the beforeFilter, but in the current version, we load behaviors/components/helpers inside of the &lt;code&gt;initialize()&lt;/code&gt; method of a class.&lt;/p&gt;

&lt;p&gt;We also need to allow access to our logout action - as well as let users actually register. In all other actions, we’ll currently allow &lt;em&gt;everything&lt;/em&gt; to happen - and lock this down as we build out the application! We can do so by adding access to those methods from within our &lt;code&gt;AppController::beforeFilter()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// Also include `use Cake\Event\Event;` at the top of your class
public function beforeFilter(Event $event) {
    parent::beforeFilter($event);
    if ($this-&amp;gt;request-&amp;gt;controller == &#39;Users&#39;) {
        $this-&amp;gt;Auth-&amp;gt;allow([&#39;add&#39;, &#39;logout&#39;]);
    } else {
        $this-&amp;gt;Auth-&amp;gt;allow();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One last thing is that we need to take care of password hashing. Since CakePHP 2, the framework does not automatically hash password fields. This is due to developers getting weird errors with non-user password fields being hashed (or not hashed!) with certain configurations. In CakePHP 3, we can handle this easily by adding a new setter method for the &lt;code&gt;password&lt;/code&gt; field to our &lt;code&gt;app/src/Model/Entity/User.php&lt;/code&gt; entity. Note that setter methods are prefixed by &lt;code&gt;_set&lt;/code&gt; and the field is &lt;code&gt;UpperCamelCase&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;// Also include `use Cake\Auth\DefaultPasswordHasher;` at the top of your class
protected function _setPassword($password) {
    return (new DefaultPasswordHasher)-&amp;gt;hash($password);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we now have a functioning authentication layer on top of our store application. A couple notes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We can no longer re-bake our user Entity or Table classes. Boo. A wise developer would crack open new bake templates and add in the appropriate hooks to include traits instead of adding methods, or even switch those methods to bake elements.&lt;/li&gt;
  &lt;li&gt;It would be useful to create a shell to pre-seed users from random data or custom data. You may guess what the next blog post will concern :)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’ll cover those over the next few installment of CakeAdvent 2014. Be sure to follow along via twitter on &lt;a href=&quot;https://twitter.com/savant&quot;&gt;@savant&lt;/a&gt;. If you’d like to subscribe to this blog, you may follow the &lt;a href=&quot;http://josediazgonzalez.com/atom.xml&quot;&gt;rss feed here&lt;/a&gt;. Also, all posts in the series will be conveniently linked on the sidebar of every post in the 2014 CakeAdvent Calendar. Come back tomorrow for more delicious content.&lt;/p&gt;
</description>
        <pubDate>Thu, 11 Dec 2014 18:26:00 +0000</pubDate>
        <link>http://josediazgonzalez.com/2014/12/11/adding-an-authentication-layer-to-our-cakephp-store/</link>
        <guid isPermaLink="true">http://josediazgonzalez.com/2014/12/11/adding-an-authentication-layer-to-our-cakephp-store/</guid>
        
        <category>cakeadvent-2014</category>
        
        <category>cakephp</category>
        
        <category>composer</category>
        
        
        <category>cakephp</category>
        
      </item>
    
  </channel>
</rss>
